"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[198],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=a.createContext({}),d=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=d(e.components);return a.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),h=d(n),m=o,u=h["".concat(s,".").concat(m)]||h[m]||c[m]||i;return n?a.createElement(u,r(r({ref:t},p),{},{components:n})):a.createElement(u,r({ref:t},p))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:o,r[1]=l;for(var d=2;d<i;d++)r[d]=n[d];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},9529:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>c,frontMatter:()=>i,metadata:()=>l,toc:()=>d});var a=n(3117),o=(n(7294),n(3905));const i={title:"Relations",slug:"/content-manager/relations",description:"Conceptual guide to relations in the Content Manager focussing on the technical decisions taken.",tags:["content-manager","relations","redux-store"]},r=void 0,l={unversionedId:"core/content-manager/relations",id:"core/content-manager/relations",title:"Relations",description:"Conceptual guide to relations in the Content Manager focussing on the technical decisions taken.",source:"@site/docs/core/content-manager/relations.mdx",sourceDirName:"core/content-manager",slug:"/content-manager/relations",permalink:"/content-manager/relations",draft:!1,editUrl:"https://github.com/strapi/strapi/tree/main/docs/docs/core/content-manager/relations.mdx",tags:[{label:"content-manager",permalink:"/tags/content-manager"},{label:"relations",permalink:"/tags/relations"},{label:"redux-store",permalink:"/tags/redux-store"}],version:"current",frontMatter:{title:"Relations",slug:"/content-manager/relations",description:"Conceptual guide to relations in the Content Manager focussing on the technical decisions taken.",tags:["content-manager","relations","redux-store"]},sidebar:"docs",previous:{title:"Introduction",permalink:"/content-manager"},next:{title:"Introduction",permalink:"/core/content-type-builder/intro"}},s={},d=[{value:"Summary",id:"summary",level:2},{value:"Data management in frontend",id:"data-management-in-frontend",level:2},{value:"Preparing relation fields in the store",id:"preparing-relation-fields-in-the-store",level:3},{value:"Handling updates to relation fields",id:"handling-updates-to-relation-fields",level:3},{value:"Cleaning data to be posted to the API",id:"cleaning-data-to-be-posted-to-the-api",level:3},{value:"Frontend component architecture",id:"frontend-component-architecture",level:2}],p={toc:d};function c(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"summary"},"Summary"),(0,o.kt)("p",null,"Relations are a term used to describe how two or more entities are connected. Previously in the sidebar of an entity,\nin Nov2020 we released a refactor that moved these fields into the main editing flow for a better editor experience\nand to improve performance of the CMS application when many relations were used."),(0,o.kt)("img",{src:"/img/content-manager/relations/component-example.png",alt:"An example of the relations input in the CMS edit view"}),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"above: An example of the relations input in the CMS edit view")),(0,o.kt)("h2",{id:"data-management-in-frontend"},"Data management in frontend"),(0,o.kt)("img",{src:"/img/content-manager/relations/relations-statemanagemen-diagram.png",alt:"a diagram overview explaining how state management works in relations"}),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"above: A high-level diagram of how relations state management works")),(0,o.kt)("h3",{id:"preparing-relation-fields-in-the-store"},"Preparing relation fields in the store"),(0,o.kt)("p",null,"When you first open an existing entity, we call the admin API and put the data into the store to pre-populate fields\nwith existing values. However, its important to know when you have fields with ",(0,o.kt)("inlineCode",{parentName:"p"},"type === 'relation'")," in your schema\nthat the data you receive will not be an array, but rather an object with the count of how many relations in that\nfield exist. For example, a section of the response may look like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "my_relations": {\n    "count": 6\n  }\n}\n')),(0,o.kt)("p",null,"So without intervention, your inputs would try to append new relations to the ",(0,o.kt)("inlineCode",{parentName:"p"},"my_relations")," object, which would not\nwork. Instead of this, before calling the redux action ",(0,o.kt)("inlineCode",{parentName:"p"},"INIT_FORM")," we recursively find the paths fields based on the\nfollowing conditions:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The field is a relation"),(0,o.kt)("li",{parentName:"ul"},"The field is a component"),(0,o.kt)("li",{parentName:"ul"},"The field is a repeatable component"),(0,o.kt)("li",{parentName:"ul"},"The field is a dynamic zone")),(0,o.kt)("p",null,"These paths ",(0,o.kt)("em",{parentName:"p"},"do not")," take into account index values. So if you have a repetable component field where the schema looks like:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "repeatable_single_component_relation": {\n    "type": "component",\n    "repeatable": true,\n    "component": "basic.relation"\n  }\n}\n')),(0,o.kt)("p",null,"and the components looks like:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "basic.relation": {\n    "attributes": {\n      "id": {\n        "type": "integer"\n      },\n      "categories": {\n        "type": "relation",\n        "relation": "oneToMany",\n        "target": "api::category.category",\n        "targetModel": "api::category.category",\n        "relationType": "oneToMany"\n      },\n      "my_name": {\n        "type": "string"\n      }\n    }\n  }\n}\n')),(0,o.kt)("p",null,"Then the path to the relation field would be ",(0,o.kt)("inlineCode",{parentName:"p"},"repeatable_single_component_relation.categories"),". Even though when\nrelations are added the path to the field in the redux store would be ",(0,o.kt)("inlineCode",{parentName:"p"},"repeatable_single_component_relation.0.categories"),"."),(0,o.kt)("p",null,"Inside the reducer we reduce the array of ",(0,o.kt)("inlineCode",{parentName:"p"},"relationalFieldPaths")," to an object with the ",(0,o.kt)("inlineCode",{parentName:"p"},"initialValues")," clone as\nas the base. If there is ",(0,o.kt)("inlineCode",{parentName:"p"},"modifiedData")," in the browser i.e. you've made changes to the entity and saved those changes,\nwe just replace the first level of the field with the ",(0,o.kt)("inlineCode",{parentName:"p"},"modifiedData")," so the data structure is preserved and we're not\nloosing the relations we had already loaded in the component. If the first part of the path is highlighted as the\n",(0,o.kt)("inlineCode",{parentName:"p"},"relationalField")," then we simply replace that intial object with an empty array."),(0,o.kt)("p",null,"However, if the first part of the path is either a repeatable component, a dynamic zone or a regular component then we\nrecursively find the relation fields and replace the object with an array. This is handled by the ",(0,o.kt)("inlineCode",{parentName:"p"},"findLeafByPathAndReplace"),"\nutility function. This function in short, takes an end path (in this case the relational field) and a primitive to replace\nwhen it finds the endpath (an empty array in this case). It then recursively reduces the paths to the relational field mapping\nthrough arrays if necessary (in the instance of repetable components for example) replacing the endpath with the primitive."),(0,o.kt)("p",null,"When this is done, we have sucessfully prepared our initial data for usage with relations."),(0,o.kt)("h3",{id:"handling-updates-to-relation-fields"},"Handling updates to relation fields"),(0,o.kt)("p",null,"Because we've prepared the fields prior to the component loading, adding & removing relations, it's relatively easy to do so.\nWhen a relation is added, we simply push the new relation to the array of relations. When a relation is removed, we simply\nfilter out the relation from the array of relations. This is handled inside the reducer actions ",(0,o.kt)("inlineCode",{parentName:"p"},"CONNECT_RELATION")," &\n",(0,o.kt)("inlineCode",{parentName:"p"},"DISCONNECT_RELATION")," respectively."),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},"Connecting relations adds the item to the end of the list, whilst loading more relations prepends to\nthe beginning of the list. This is the expected behaviour.")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"RelationInput")," component takes the field in ",(0,o.kt)("inlineCode",{parentName:"p"},"modifiedData")," as its source of truth. You could therefore consider this to\nbe the ",(0,o.kt)("inlineCode",{parentName:"p"},"browserState")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"initialData")," to be the ",(0,o.kt)("inlineCode",{parentName:"p"},"serverState"),". When relations are loaded they're added to both the ",(0,o.kt)("inlineCode",{parentName:"p"},"intialData"),"\nand ",(0,o.kt)("inlineCode",{parentName:"p"},"modifiedData")," objects, but when you connect/disconnect only the ",(0,o.kt)("inlineCode",{parentName:"p"},"modifiedData")," is updated. This is useful when we're preparing\ndata for the api."),(0,o.kt)("h3",{id:"cleaning-data-to-be-posted-to-the-api"},"Cleaning data to be posted to the API"),(0,o.kt)("p",null,"The API to update the enttiy expects relations to be categorised into two groups, a ",(0,o.kt)("inlineCode",{parentName:"p"},"connect")," array and ",(0,o.kt)("inlineCode",{parentName:"p"},"disconnect")," array.\nYou could do this as the user interacts with the input but we found this to be confusing and then involved us managing three\ndifferent arrays which makes the code more complex. Instead, because the browser doesn't really care about whats new and removed\nand we have a copy of the slice of data we're mutating from the server we can run a small diff algorithm to determine which\nrelations have been connected and which have been disconnected. Returning an object like so:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "my_relations": {\n    "connect": [{ "id": 1 }, { "id": 2 }],\n    "disconnect": []\n  }\n}\n')),(0,o.kt)("h2",{id:"frontend-component-architecture"},"Frontend component architecture"))}c.isMDXComponent=!0}}]);